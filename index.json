[{"uri":"/RProvider/Charts-QuickStart.html","title":"Quickstart: Creating Charts\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \n# Quickstart: Creating Charts\n\nOne of the compelling features of R is its ability to create beautiful charts.\nWith the R Type Provider, you can use all of R capabilities from F#, \nand create simple charts quickly to explore and visualize your data on-the-fly, \nas well as generate publication quality graphics that can be exported to virtually any format.\n\n## Charts Basics\n\nBasic charts can be found in the graphics package. \nAssuming you installed the R Type Provider in your project from NuGet, \nyou can reference the required libraries and packages this way:\n*)\n\n// #I \u0022../packages/RProvider.1.0.11\u0022\n// #load \u0022RProvider.fsx\u0022\n\nopen System\nopen RDotNet\nopen RProvider\nopen RProvider.graphics\n\n(**\nOnce the libraries and packages have been loaded, \nproducing basic charts is as simple as this:\n*)\n\nlet widgets = [ 3; 8; 12; 15; 19; 18; 18; 20; ]\nlet sprockets = [ 5; 4; 6; 7; 12; 9; 5; 6; ]\n\nR.plot(widgets)\n\nR.plot(widgets, sprockets)\n\nR.barplot(widgets)\n\nR.hist(sprockets)\n\nR.pie(widgets)\n\n(**\n## Exporting and Saving Charts\n\nCharts can be exported and saved to various formats; \nonce you have opened the grDevices package, you can save a chart like this:\n*)\n\n// Required package to save charts\nopen RProvider.grDevices\n\n// Create path to an image testimage.png on the Desktop\nlet desktop = Environment.GetFolderPath(Environment.SpecialFolder.Desktop)  \nlet path = desktop \u002B @\u0022\\testimage.png\u0022\n\n// Open the device and create the file as a png.\n// R.bmp, R.jpeg, R.pdf, ... will generate other formats.\nR.png(filename=path, height=200, width=300, bg=\u0022white\u0022)\n// Create the chart into the file\nR.barplot(widgets)\n// Close the device once the chart is complete\nR.dev_off ()\n\n\n(**\n## Advanced Charts Options\n\nThe graphic functions exposed by the R Type Provider come in two flavors; \nthey either have optional named arguments, \nfollowed by a ParamArray for extended arguments, \nor they take named parameters, an IDictionary\u003Cstring,object\u003E \nwhich contains all the arguments passed to the function.\n\n### Named Arguments\n\nConsider for instance the following example:\n*)\n\nR.barplot(widgets)\nR.title(main=\u0022Widgets\u0022, xlab=\u0022Period\u0022, ylab=\u0022Quantity\u0022)\n\n(**\nR.title has 2 signatures, one of them with optional arguments, \ndemonstrated above to set the main title as well as the labels for the x and y axis, \nignoring some of the other available options. \nYou can see another example in the previous section in the R.png call.\n\n### Named Parameters\n\nNamed parameters allow you to specify every argument supported by R, \nas an IDictionary of string, object. \nThe string is the name of the argument, and the object its value.\n\nFinding the available arguments for a R function can be tricky;\nthe full list of arguments can usually be found in the \n[R developer documentation](http://stat.ethz.ch/R-manual/R-devel/library/),\nnavigating in the correct package. For instance, R.plot belongs to\ngraphics, and can be found \n[here](http://stat.ethz.ch/R-manual/R-devel/library/graphics/html/plot.html).\n\nThe easiest way to use that feature is to \nleverage the built-in function namedParams, like in this example:\n*)\n\nR.plot(\n    namedParams [   \n        \u0022x\u0022, box widgets; \n        \u0022type\u0022, box \u0022o\u0022; \n        \u0022col\u0022, box \u0022blue\u0022;\n        \u0022ylim\u0022, box [0; 25] ])\n\nR.lines(\n    namedParams [   \n        \u0022x\u0022, box sprockets; \n        \u0022type\u0022, box \u0022o\u0022; \n        \u0022pch\u0022, box 22;\n        \u0022lty\u0022, box 2;\n        \u0022col\u0022, box \u0022red\u0022 ])\n\n(**\nThe first call specifies what to plot (widgets), \nwhat type of line to use, the color, and the scale of the axis. \nThe second call adds sprockets, specifying lty (the line type), \nand pch (the plotting character).\n\nbox is used to reduce all elements to objects, \nso that the lists have consistent types.\n\nA possibly more elegant way to use namedParams is to follow the pattern below:\n*)\n\nnamedParams [   \n    \u0022x\u0022, box widgets; \n    \u0022type\u0022, box \u0022o\u0022; \n    \u0022col\u0022, box \u0022blue\u0022;\n    \u0022ylim\u0022, box [0; 25] ]\n|\u003E R.plot\n\nnamedParams [   \n    \u0022x\u0022, box sprockets; \n    \u0022type\u0022, box \u0022o\u0022; \n    \u0022pch\u0022, box 22;\n    \u0022lty\u0022, box 2;\n    \u0022col\u0022, box \u0022red\u0022 ]\n|\u003E R.lines"},{"uri":"/RProvider/devnotes.html","title":"Developer notes\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\nDeveloper notes\n===============\n\nThere are two things that make the R type provider tricky:\n\n * When you use R provider via NuGet and the F# compiler references the \n   R provider, it attempts to load it from the location where NuGet puts\n   it. This is typically \u0060packages/RProvider.1.0.8/lib\u0060. This directory\n   does *not* contain \u0060RDotNet.dll\u0060 (which is installed in \u0060packages/R.NET.1.3.5/lib/net40\u0060)\n   and so the loading could fail.\n\n   To avoid this, we need to make sure that the assembly that is loaded by\n   the F# compiler (and Visual Studio) does not trigger loading of R.NET\n   immediately - that way, we can setup \u0060AssemblyResolve\u0060 event handler\n   and load R.NET assembly from another directory.\n   \n * Connecting to R is not entirely stable and so we do not want to crash the\n   F# compiler (or Visual Studio) when something goes wrong with R. For this \n   reason, we run the type discovery in a separate process and communicate\n   with it via .NET remoting.\n\nProject structure\n-----------------\n\nTo solve the two issues outlined above, the project structure looks like this:\n\n\u003Cdiv style=\u0022margin:40px\u0022\u003E\n\u003Cimg src=\u0022misc/diagram.png\u0022 /\u003E\n\u003C/div\u003E\n\nThings to keep in mind\n----------------------\n\nHere is what you need to know about individual assemblies in the solution:\n\n * \u0060RProvider.Runtime.dll\u0060 - this is the assembly that contains most of the \n   interesting runtime functionality (such as initialization of R, interop\n   with R and converters that convert values between F# and R). It also contains\n   helpers (logging, etc.). \n   \n   This assembly references R.NET in its public assemblies and so when it\n   is loaded, .NET needs to be able to load R.NET (i.e. the \u0060AssemblyResolve\u0060\n   event handler needs to be set up).\n\n * \u0060RProvider.dll\u0060 - this is the assembly that the user of R provider will \n   reference. It does not contain any useful code - it only contains \n   \u0060TypeProviderAssembly\u0060 attribute pointing to the assembly with the actual\n   type provider code. \n   \n   Note that we cannot put the functionality from \u0060RProvider.Runtime.dll\u0060 \n   here, because the code needs to be referenced by the other two assemblies\n   (that are compiled before the type provider can be loaded).\n\n * \u0060RProvider.DesignTime.dll\u0060 - this is where the type provider code lives.\n   This sets up \u0060AssemblyResolve\u0060 event handler and then it generates types\n   (by calling the \u0060RProvider.Server.exe\u0060 to do the type discovery).\n\n * \u0060RProvider.Server.exe\u0060 - this is started as a stand-alone process that \n   performs type and package discovery in R. It is called by the DesignTime\n   component and restarted automatically. This also needs to setup the \n   \u0060AssemblyResolve\u0060 event handler."},{"uri":"/RProvider/reading-rdata.html","title":"Reading and writing RData files\n","content":"(*** hide ***)\n#I \u0022../../packages/FSharp.Data.2.0.7/lib/net40/\u0022\n#I \u0022../../bin/\u0022\n#r \u0022RDotNet.dll\u0022\n#r \u0022RDotNet.FSharp.dll\u0022\n#r \u0022RProvider.dll\u0022\n#r \u0022RProvider.Runtime.dll\u0022\nopen System\n(**\nReading and writing RData files\n===============================\n\nWhen using R, you can save and load data sets as \u0060*.rdata\u0060 files. These can be easily\nexported and consumed using the R provider too, so if you want to perform part of your\ndata acquisition, analysis and visualization using F# and another part using R, you \ncan easily pass the data between F# and R as \u0060*.rdata\u0060 files.\n\nPassing data from R to F#\n-------------------------\n\nLet\u0027s say that you have some data in R and want to pass them to F#. To do that, you\ncan use the \u0060save\u0060 function in R. The following R snippet creates a simple \u0060*.rdata\u0060\nfile containing a couple of symbols from the sample \u0060volcano\u0060 data set:\n\n    [lang=text]\n    require(datasets)\n    volcanoList \u003C- unlist(as.list(volcano))\n    volcanoMean \u003C- mean(volcanoList)\n    symbols \u003C- c(\u0022volcano\u0022, \u0022volcanoList\u0022, \u0022volcanoMean\u0022)\n    save(list=symols, file=\u0022C:/data/sample.rdata\u0022)\n\nTo import the data on the F# side, you can use the \u0060RData\u0060 type provider that is\navailable in the \u0060RProvider\u0060 namespace. It takes a static parameter specifying the\npath of the file (absolute or relative) and generates a type that exposes all the\nsaved values as static members:\n*)\nopen RProvider\n\ntype Sample = RData\u003C\u0022data/sample.rdata\u0022\u003E\nlet sample = Sample()\n\n// Easily access saved values\nsample.volcano\nsample.volcanoList\nsample.volcanoMean\n\n(**\nWhen accessed, the type provider automatically converts the data from the R format\nto F# format. In the above example, \u0060volcanoList\u0060 is imported as \u0060float[]\u0060 and\nthe \u0060volcanoMean\u0060 value is a singleton array. (The provider does not detect that \nthis is a singleton, so you can get the value using \u0060sample.volcanoMean.[0]\u0060).\nFor the \u0060sample.volcano\u0060 value, the R provider does not have a default conversion\nand so it is exposed as \u0060SymbolicExpression\u0060. \n\nWhen you have a number of \u0060*.rdata\u0060 files containing data in the same format, you can\npick one of them as a sample (which will be used to determine the fields of the type)\nand then pass the file name to the constructor of the generated type to load it.\nFor example, if we had files \u0060data/sample_1.rdata\u0060 to \u0060data/sample_10.rdata\u0060, we could\nread them as:\n*)\nlet means = \n  [ for i in 1 .. 10 -\u003E\n      let data = Sample(sprintf \u0022data/sample_%d.rdata\u0022 i)\n      data.volcanoMean.[0] ]\n(**\nNote that the default conversions available depend on the plugins that are currently\navailable. For example, when you install the enrie [FsLab](http://www.fslab.org) package\nwith the [Deedle](https://fslab.org/Deedle/) library, the \u0060RData\u0060 \nprovider will automatically expose data frames as Deedle \u0060Frame\u003Cstring, string\u003E\u0060 values.\n\nPassing data from F# to R\n-------------------------\n\nIf you perform data acquisition in F# and then want to pass the data to R, you \ncan use the standard R functions for saving the \u0060*.rdata\u0060 files. The easiest \noption is to call the \u0060R.assign\u0060 function to define named values in the R environment\nand then use \u0060R.save\u0060 to save the environment to a file:\n*)\n// Calculate sum of square differences\nlet avg = sample.volcanoList |\u003E Array.average\nlet sqrs = \n  sample.volcanoList \n  |\u003E Array.map (fun v -\u003E pown (v - avg) 2)\n\n// Save the squares to an RData file\nR.assign(\u0022volcanoDiffs\u0022, sqrs)\nR.save(list=[ \u0022volcanoDiffs\u0022 ], file=\u0022C:/temp/volcano.rdata\u0022)\n(**\nIt is recommended to use the \u0060list\u0060 parameter of the \u0060save\u0060 function to specify the\nnames of the symbols that should be saved, rather than saving *all* symbols. The R\nprovider uses additional temporary symbols and so the saved file would otherwise contain\nunnecessary fileds.\n\nOnce you save the file using the above command, you can re-load it again using\nthe \u0060RData\u0060 type provider, such as: \u0060new RData\u003C\u0022C:/temp/volcano.rdata\u0022\u003E()\u0060.\n*)"},{"uri":"/RProvider/howto.html","title":"How to\n","content":"---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n\n# How to\n\n## Packages\n\n### How do I Load a Package?\n\nRProvider discovers the packages installed in your R installation and makes them available as packages under the RProvider root namespace.  The actual package is lazily loaded the first time you access it.  \n\n### How do I install a new Package?\n\nCurrently you need to load up a real R session, then install the package via install.packages, or the Packages/Install Packages... menu.  You will then need to restart Visual Studio because the set of installed packages is cached inside the RProvider.\n\n#### I have a package installed and it is not showing up\nThe most likely cause is that RProvider is using a different R installation from the one you updated.  When you install R, you get the option to update the registry key \u0060HKEY_LOCAL_MACHINE\\SOFTWARE\\R-core\u0060 to point to the version you are installing.  This is what RProvider uses.  If you are running in a 32-bit process, RProvider uses \u0060HKEY_LOCAL_MACHINE\\SOFTWARE\\R-core\\R\\InstallPath\u0060 to determine the path.  For 64-bit, it reads \u0060HKEY_LOCAL_MACHINE\\SOFTWARE\\R-core\\R64\\InstallPath\u0060.  When you install a package in a given version of R, it should be available in both the 32-bit and 64-bit versions.\n\n## Function and Package names\nThere are a couple of mismatches between allowed identifiers between R and F#:\n### Dots in names\nIt is pretty common in R to use a dot character in a name, because the character has no special meaning.  We remap dots to underscore, and underscore to a double-underscore.  So for example, data.frame() becomes R.data_frame().\n\n### Names that are reserved F# keywords\nSome package and function names are reserved words in F#.  For these, you will need to quote them using double-backquotes.  Typically, the IDE will do this for you.  A good example is the base package, which will require an open statement where \u0022base\u0022 is double-back-quoted.\n"},{"uri":"/RProvider/passing-data.html","title":"Passing Data Between F# and R\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n#r \u0022RProvider.dll\u0022\n#r \u0022RProvider.DesignTime.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n\nopen System\nopen RDotNet\nopen RProvider\n\n(**\n# Passing Data Between F# and R\n\n## Passing Parameters\n\n### Parameter Passing Conventions\n\nR supports various kinds of parameters, which we try to map onto equivalent F# parameter types:\n\n * All R formal parameters have names, and you can always pass their values either by name or positionally.  If you pass by name, you can skip arguments in your actual argument list.  We simply map these onto F# arguments, which you can also pass by name or positionally.\n\n * In R, essentially all arguments are optional (even if no default value is specified in the function argument list).  It\u0027s up to the receiving function to determine whether to error if the value is missing.   So we make all arguments optional.\n\n * R functions support ... (varargs/paramarray).  We map this onto a .NET ParamArray, which allows an arbitrary number of arguments to be passed.  However, there are a couple of kinks with this:\n\n    * R allows named arguments to appear _after_ the ... argument, whereas .NET requires the ParamArray argument to be at the end.  Some R functions use this convention because their primary arguments are passed in the ... argument and the named arguments will sometimes be used to modify the behavior of the function.  From the RProvider you will to supply values for the positional arguments before you can pass to the ... argument.  If you don\u0027t want to supply a value to one of these arguments, you can explicitly pass System.Reflection.Missing.\n\n    * Parameters passed to the R ... argument can also be passed using a name.  Those names are accessible to the calling function.  Example are list and dataframe construction (R.list, and R.data_frame).  To pass arguments this way, you can use the overload of each function that takes an IDictionary\u003Cstring, obj\u003E, either directly, or using the namedParams function.  For example:\n\n        R.data_frame(namedParams [ \u0022A\u0022, [|1;2;3|]; \u0022B\u0022, [|4;5;6|] ])\n\n### Parameter Types\n\nSince all arguments to functions are of type obj, it is not necessarily obvious what you can pass.  Ultimately, you will need to know what the underlying function is expecting, but here is a table to help you.  When reading this, remember that for most types, R supports only vector types.  There are no scalar string, int, bool etc. types.\n\n\u003Ctable class=\u0022table table-bordered table-striped\u0022\u003E\n\u003Ctr\u003E\u003Cth\u003ER Type\u003C/th\u003E\u003Cth\u003EF#/.NET Type\u003C/th\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter\u003C/td\u003E\u003Ctd\u003Estring or string[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex\u003C/td\u003E\u003Ctd\u003ESystem.Numerics.Complex or Complex[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger\u003C/td\u003E\u003Ctd\u003Eint or int[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical\u003C/td\u003E\u003Ctd\u003Ebool or bool[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric\u003C/td\u003E\u003Ctd\u003Edouble or double[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elist\u003C/td\u003E\u003Ctd\u003ECall R.list, passing the values as separate arguments\u003C/td\u003E\u003Ctr\u003E\n\u003Ctr\u003E\u003Ctd\u003Edataframe\u003C/td\u003E\u003Ctd\u003ECall R.data_frame, passing column vectors in a dictionary\u003C/td\u003E\u003Ctr\u003E\n\u003C/table\u003E\n\n**NB**: For any input, you can also pass a SymbolicExpression instance you received as the result of calling another R function.  Doing so it a very efficient way of passing data from one function to the next, since there is no marshalling between .NET and R types in that case.\n\n### Creating and passing an R function\nR has some high-level functions (e.g. sapply) that require a function parameter. Although F# has first-class support of functional programming and provides better functionality and syntax for apply-like operations, which often makes it sub-optimal to call apply-like high-level functions in R, the need for parallel computing in R, which is not yet directly supported by F# parallelism to R functions, requires users to pass a function as parameter. Here is an example way to create and pass an R function:\n*)\nlet fun1 = R.eval(R.parse(text=\u0022function(i) {mean(rnorm(i))}\u0022))\nlet nums = R.sapply(R.c(1,2,3),fun1)\n(**\nThe same usage also applies to parallel apply functions in parallel package.\n\n## Accessing results\n\nFunctions exposed by the RProvider return an instance of \u0060RDotNet.SymbolicExpression\u0060.  This keeps all return data inside R data structures, so does not impose any data marshalling overhead.  If you want to pass the value in as an argument to another R function, you can simply do so.\n\nIn order to access the result in .NET code, you have three routes:\n\n### Convert the data into a specified .NET type via GetValue\u003Ctype\u003E()\n\nRProvider adds a generic \u0060GetValue\u003C\u0027T\u003E\u0060 extension method to \u0060SymbolicExpression\u0060.  This supports conversions from certain R values to specific .NET types.  Here are the currently supported conversions:\n\n\u003Ctable class=\u0022table table-bordered table-striped\u0022\u003E\n\u003Ctr\u003E\u003Cth\u003ER Type\u003C/th\u003E\u003Cth\u003ERequested F#/.NET Type\u003C/th\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Estring\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter\u003C/td\u003E\u003Ctd\u003Estring[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex (when vector is length 1)\u003C/td\u003E\u003Ctd\u003EComplex\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex\u003C/td\u003E\u003Ctd\u003EComplex[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Eint\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger\u003C/td\u003E\u003Ctd\u003Eint[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Ebool\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical\u003C/td\u003E\u003Ctd\u003Ebool[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Edouble\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric\u003C/td\u003E\u003Ctd\u003Edouble[]\u003C/td\u003E\u003C/tr\u003E\n\u003C/table\u003E\n\nCustom conversions can be supported through [plugins](plugins.html).\n\n### Convert the data into the default .NET type the .Value property\n\nWe also expose an extension property called Value that performs a _default_ conversion of a SymbolicExpresion to a .NET type.  These are the current conversions:\n\n\u003Ctable class=\u0022table table-bordered table-striped\u0022\u003E\n\u003Ctr\u003E\u003Cth\u003ER Type\u003C/th\u003E\u003Cth\u003EF#/.NET Type\u003C/th\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter\u003C/td\u003E\u003Ctd\u003Estring[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex\u003C/td\u003E\u003Ctd\u003EComplex[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger\u003C/td\u003E\u003Ctd\u003Eint[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical\u003C/td\u003E\u003Ctd\u003Ebool[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric\u003C/td\u003E\u003Ctd\u003Edouble[]\u003C/td\u003E\u003C/tr\u003E\n\u003C/table\u003E\n\nAgain, custom conversions can be supported through [plugins](plugins.html).\n\n### Explicitly access the data in the SymbolicExpression\n\nIf there are no supported conversions, you can access the data through the RDotNet object model.  RDotNet exposes properties, members and extension members (available only if you open the RDotNet namespace) that allow you to access the underlying data directly.  So, for example:\n*)\n\nlet res = R.sum([|1;2;3;4|])\nif res.Type = RDotNet.Internals.SymbolicExpressionType.IntegerVector then res.AsInteger().[0]\nelse failwithf \u0022Expecting a Numeric but got a %A\u0022 res.Type\n\n(**\nTo make this easier, we have defined some active patterns, under the RProvider.Helpers namespace, which is auto-opened when you open the RProvider namespace.  These combine the type tests and conversion.  An equivalent example:\n*)\n\nmatch R.sum([|1;2;3;4|]) with \n| IntegerVector(iv) -\u003E iv.[0]\n| _                 -\u003E failwithf \u0022Expecting a Numeric but got a %A\u0022 res.Type\n\n(**\n## What if I commonly need an argument or result conversion that RProvider does not support?\n\nIf you believe the argument conversion is universally appropriate and should be available to everybody, please fork the repo and submit a pull request.\n\nRProvider also supports custom conversions to/from your own data types using [plugins](plugins.html).\n*)"},{"uri":"/RProvider/Statistics-QuickStart.html","title":"Quickstart: Using Statistical Packages\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n#r \u0022RProvider.dll\u0022\n#r \u0022RProvider.DesignTime.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \n# Quickstart: Using Statistical Packages\n\nR is a programming language designed for statistics and data mining.\nThe R community is strong, and created an incredibly rich open source\necosystem of packages. \n\nThe F# R Type Provider enables you to use every single one of them,\nfrom within the F# environment. You can manipulate data using F#,\nsend it to R for computation, and extract back the results.\n\n## Example: Linear Regression\n\nLet\u0027s perform a simple linear regression from the F# interactive, \nusing the R.lm function.\n\nAssuming you installed the R Type Provider in your project from NuGet, \nyou can reference the required libraries and packages this way:\n*)\n\n#I \u0022../packages/RProvider.1.0.11\u0022\n#load \u0022RProvider.fsx\u0022\n\nopen System\nopen RDotNet\nopen RProvider\nopen RProvider.graphics\nopen RProvider.stats\n\n(**\nOnce the libraries and packages have been loaded, \nImagine that our true model is\n\nY = 5.0 \u002B 3.0 * X1 - 2.0 * X2 \u002B noise\n\nLet\u0027s generate a fake dataset that follows this model:\n*)\n\n// Random number generator\nlet rng = Random()\nlet rand () = rng.NextDouble()\n\n// Generate fake X1 and X2 \nlet X1s = [ for i in 0 .. 9 -\u003E 10. * rand () ]\nlet X2s = [ for i in 0 .. 9 -\u003E 5. * rand () ]\n\n// Build Ys, following the \u0022true\u0022 model\nlet Ys = [ for i in 0 .. 9 -\u003E 5. \u002B 3. * X1s.[i] - 2. * X2s.[i] \u002B rand () ]\n\n(**\nUsing linear regression on this dataset, we should be able to \nestimate the coefficients 5.0, 3.0 and -2.0, with some imprecision\ndue to the \u0022noise\u0022 part.\n\nLet\u0027s first put our dataset into a R dataframe; this allows us\nto name our vectors, and use these names in R formulas afterwards:\n*)\n\nlet dataset =\n    namedParams [\n        \u0022Y\u0022, box Ys;\n        \u0022X1\u0022, box X1s;\n        \u0022X2\u0022, box X2s; ]\n    |\u003E R.data_frame\n\n(**\nWe can now use R to perform a linear regression.\nWe call the [R.lm function](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html),\npassing it the formula we want to estimate. \n(See the [R manual on formulas](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/formula.html) \nfor more on their somewhat esoteric construction) \n*)\n\nlet result = R.lm(formula = \u0022Y~X1\u002BX2\u0022, data = dataset)\n\n(**\n## Extracting Results from R to F#\n\nThe result we get back from R is a R Expression. \nThe R Type Provider tries as much as possible to keep data\nas R Expressions, rather than converting back-and-forth\nbetween F# and R types. It limits translations \nbetween the 2 languages, which has performance benefits, \nand simplifies composing R operations. On the other hand, \nwe need to extract the results from the R expression \ninto F# types.\n\nThe [R docs for lm](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html) \ndescribes what R.lm returns: a R List. We can now retrieve each element, \naccessing it by name (as defined in the documentation). \nFor instance, let\u0027s retrieve the coefficients and residuals, \nwhich are both R vectors containg floats:\n*)\n\nlet coefficients = result.AsList().[\u0022coefficients\u0022].AsNumeric()\nlet residuals = result.AsList().[\u0022residuals\u0022].AsNumeric()\n\n(**\nWe can also produce summary statistics about our model,\nlike R^2, which measures goodness-of-fit - close to 0\nindicates a very poor fit, and close to 1 a good fit.\nSee [R docs for the details on Summary](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/summary.lm.html).\n*)\n\nlet summary = R.summary(result)\nsummary.AsList().[\u0022r.squared\u0022].AsNumeric()\n\n(**\nFinally, we can directly pass results, which is a R expression,\nto R.plot, to produce some fancy charts describing our model:\n*)\n\nR.plot result\n\n(**\nThat\u0027s it - while simple, we hope this example illustrate\nhow you would go about to use any existing R statistical package. \nWhile the details would differ, the general approach would\nremain the same. Happy modelling!\n*)"},{"uri":"/RProvider/tutorial.html","title":"R Provider Tutorial\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n#r \u0022RProvider.dll\u0022\n#r \u0022RProvider.DesignTime.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \n# R Provider Tutorial\n\n## Referencing the provider\n\nIn order to use the R provider, you need to reference the \u0060RDotNet.dll\u0060 library\n(which is a .NET connector for R) and the \u0060RProvider.dll\u0060 itself. For this tutorial,\nwe use \u0060open\u0060 to reference a number of packages including \u0060stats\u0060, \u0060tseries\u0060 and \u0060zoo\u0060:\n*)\n \nopen RDotNet\nopen RProvider\nopen RProvider.graphics\nopen RProvider.stats\nopen RProvider.tseries\nopen RProvider.zoo\n\nopen System\nopen System.Net\n(**\nIf either of the namespaces above are unrecognized, you need to install the package in R\nusing \u0060install.packages(\u0022stats\u0022)\u0060.\n\n## Obtaining data\n\nIn this tutorial, we use [F# Data](http://fsharp.github.io/FSharp.Data/) to access stock\nprices from the Yahoo Finance portal. For more information, see the documentation for the\n[CSV type provider](http://fsharp.github.io/FSharp.Data/library/CsvProvider.html).\n\nThe following snippet uses the CSV type provider to generate a type \u0060Stocks\u0060 that can be\nused for parsing CSV data from Yahoo. Then it defines a function \u0060getStockPrices\u0060 that returns\narray with prices for the specified stock and a specified number of days:\n*)\n#r \u0022FSharp.Data.dll\u0022\nopen FSharp.Data\n\ntype Stocks = CsvProvider\u003C\u0022http://ichart.finance.yahoo.com/table.csv?s=SPX\u0022\u003E\n \n/// Returns prices of a given stock for a specified number \n/// of days (starting from the most recent)\nlet getStockPrices stock count =\n  let url = \u0022http://ichart.finance.yahoo.com/table.csv?s=\u0022\n  [| for r in Stocks.Load(url \u002B stock).Take(count).Rows -\u003E float r.Open |] \n  |\u003E Array.rev\n\n/// Get opening prices for MSFT for the last 255 days\nlet msftOpens = getStockPrices \u0022MSFT\u0022 255\n\n(**\n## Calling R functions\n\nNow, we\u0027re ready to call R functions using the type provider. The following snippet takes\n\u0060msftOpens\u0060, calculates logarithm of the values using \u0060R.log\u0060 and then calculates the \ndifferences of the resulting vector using \u0060R.diff\u0060:\n*)\n\n// Retrieve stock price time series and compute returns\nlet msft = msftOpens |\u003E R.log |\u003E R.diff\n\n\n(**\nIf you want to see the resulting values, you can call \u0060msft.AsVector()\u0060 in F# Interactive.\nNext, we use the \u0060acf\u0060 function to display the atuo-correlation and call \u0060adf_test\u0060 to\nsee if the \u0060msft\u0060 returns are stationary/non-unit root:\n*)\n\nlet a = R.acf(msft)\nlet adf = R.adf_test(msft) \n\n(**\nAfter running the first snippet, a window similar to the following should appear (note that\nit might not appear as a top-most window).\n\n\u003Cdiv style=\u0022text-align:center\u0022\u003E\n\u003Cimg src=\u0022images/acf.png\u0022 /\u003E\n\u003C/div\u003E\n\nFinally, we can obtain data for multiple different indicators and use the \u0060R.pairs\u0060 function\nto produce a matrix of scatter plots:\n*)\n\n// Build a list of tickers and get diff of logs of prices for each one\nlet tickers = \n  [ \u0022MSFT\u0022; \u0022AAPL\u0022; \u0022X\u0022; \u0022VXX\u0022; \u0022SPX\u0022; \u0022GLD\u0022 ]\nlet data =\n  [ for t in tickers -\u003E \n      printfn \u0022got one!\u0022\n      t, getStockPrices t 255 |\u003E R.log |\u003E R.diff ]\n\n// Create an R data frame with the data and call \u0027R.pairs\u0027\nlet df = R.data_frame(namedParams data)\nR.pairs(df)\n\n(**\nAs a result, you should see a window showing results similar to these:\n\n\u003Cdiv style=\u0022text-align:center\u0022\u003E\n\u003Cimg src=\u0022images/pairs.png\u0022 /\u003E\n\u003C/div\u003E\n\n*)"},{"uri":"/RProvider/internals.html","title":"How does it work?\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\n# How does it work?\n\n## How do we call into R?\nThe RProvider loads the R.DLL (which contains the core of R) into the calling process, via [RDotNet](http://rdotnet.codeplex.com/).  This will happen in several places:\n\n* In the IDE, to provide IntelliSense for packages/functions/parameters.\n* In the F# compiler, to generate code that calls the R functionality you are calling.\n* In your resulting binary, to execute the generated code.\n* In F# Interactive, to do all of the above interactively.\n\n## How does RDotNet help?\nRDotNet allows R functionality to be called from .NET, and exposes an object model for representing R values (based on the type RDotNet.SymbolExpression).  Using RDotNet, one executes R code by passing strings of R code into an Evaluate method.  From the RProvider, we introspect on available R packages and functions and expose them as members of provided types.  You can then call them just like regular .NET functions, with IntelliSense and compile-time checking.  RDotNet.SymbolicExpression provides a nice OO model of the R native SEXP type, so we simply expose results using that type.  To make it more friendly from F#, we extend it with some extension members and active patterns.\n\n## How do we expose R packages?\nRProvider determines the set of installed packages in your R installation and exposes them as namespaces under the root RProvider namespace.  This allows you to \u0027open\u0027 the namespaces you want to use as if they were regular .NET namespaces.\n\nUnder the namespace for a given package, RProvider exposes a single static type called \u0022R\u0022, which contains static methods mirroring each of the functions and values that exist in the package.  This means that the members under \u0022R.\u0022 will be the union of available functions in all of the package namespaces you have opened.\n\n## Is it Statically Typed?\nKind of.  It is statically type checked to the extent that it can be given the type information available from R.  In practice, this means that the F# compiler and IDE statically checks that the function you are calling exists in the package you are calling.  In some cases, we can also determine that you are not passing too many arguments to the function, though common use of ... (aka varargs/params) in R functions defeats that in many cases.\n\nR is dynamically typed, so we cannot determine what the types of function arguments are supposed to be.  So all arguments are of type obj.  R functions can also be written such that they will work even if arguments that do not have default values are omitted, so we expose each argument as optional.  And for R functions that accept a ... argument, we expose a paramarray argument that allows any number of additional arguments to be passed.  In that case, you can basically pass any number of arguments to the function."},{"uri":"/RProvider/index.html","title":"F# R Type Provider\n","content":"F# R Type Provider\n=======\n\n\nThe F# Type Provider is a mechanism that enables smooth interoperability\nbetween F# and [R](http://www.r-project.org/). \nThe Type Provider discovers R packages that are available \nin your R installation and makes them available as .NET namespaces \nunderneath the parent namespace \u0060RProvider\u0060. \n\nThe Type Provider makes it possible to use \nall of R capabilities, from the F# interactive environment. \nIt enables on-the-fly charting and data analysis using R packages, \nwith the added benefit of IntelliSense over R, \nand compile-time type-checking that the R functions you are using exist. \nIt allows you to leverage all of .NET libraries,\nas well as F# unique capabilities to access and manipulate data \nfrom a wide variety of sources via Type Providers.\n\n### A Quick Demo\n\n\u003Cdiv style=\u0022text-align:center;\u0022\u003E\n\u003Ciframe width=\u0022420\u0022 height=\u0022315\u0022 src=\u0022//www.youtube.com/embed/cCuGgA9Yqrs?rel=0\u0022 frameborder=\u00220\u0022 allowfullscreen\u003E\u003C/iframe\u003E\n\u003C/div\u003E\n\n## What are R and F#?\n\n[F#](http://msdn.microsoft.com/en-us/vstudio/hh388569) is a mixed-paradigm language \nthat supports functional, object-oriented and imperative programming, \nwith the emphasis on functional. F# runs on the .NET runtime and is a compiled, \nstatically typed language with a strong type system and type inference. \nF# is a general purpose programming language, \nand is particularly well-suited for scientific/numerical computing.\n\n[R](http://www.r-project.org/) is an Open Source language for statistical computing. \nR offers a wide range of high-quality, community-developed packages, \ncovering virtually every area of statistics, econometrics or machine learning. \nIt is also famous for its charting capabilities, making it a great tool \nto produce publication-quality graphics. \nR is an interpreted, dynamically typed language that is typically used \nfrom its GUI, [RStudio](http://www.rstudio.com/), or command line interactive environment.\n\n## Using the R Type Provider\n\n\u003Cdiv class=\u0022row\u0022\u003E\n  \u003Cdiv class=\u0022span1\u0022\u003E\u003C/div\u003E\n  \u003Cdiv class=\u0022span6\u0022\u003E\n    \u003Cdiv class=\u0022well well-small\u0022 id=\u0022nuget\u0022\u003E\n      Install using the \u003Ca href=\u0022https://nuget.org/packages/RProvider/\u0022\u003ENuGet package\u003C/a\u003E.\n      Run the following command in the \u003Ca href=\u0022http://docs.nuget.org/docs/start-here/using-the-package-manager-console\u0022\u003EPackage Manager Console\u003C/a\u003E:\n      \u003Cpre\u003EPM\u003E Install-Package RProvider\u003C/pre\u003E\n    \u003C/div\u003E\n  \u003C/div\u003E\n  \u003Cdiv class=\u0022span1\u0022\u003E\u003C/div\u003E\n\u003C/div\u003E\n\n### Pre-requisites\n\nThe R Provider requires an installation of R for Windows, downloadable from\n[here](http://cran.cnr.berkeley.edu/bin/windows/base/).  RProvider uses the R registry key\n\u0060SOFTWARE\\R-core\u0060 to locate the R binary directory, in order to load \u0060R.dll\u0060.  It will also\nlocate \u0060R.dll\u0060 if it is on the path.  If run from a 32-bit process, RProvider will use\nthe 32-bit \u0060R.dll\u0060, and if run from a 64-bit process, it will load the 64-bit version.\n(Note that VS runs in 32-bit process, so you must have installed 32-bit version of R for \nWindows if you want IntelliSense to work)\n\nIf you are using R 2.15 or later, you should not try to load the RProvider inside a script\nthat is passed to FSI via the \u0060--use\u0060 flag.  It seems that something about the way R\ninitializes causes it to hang in that context.  Works fine if you load later.\n\nFor compilation you will need VS2012 / F# 3.0 or later.  For runtime you\u0027ll need .NET 4.5.\n\nContributing and copyright\n--------------------------\n\nThe project has been developed by [BlueMountain Capital](https://www.bluemountaincapital.com/)\nand contributors. It is available under the BSD license. The library uses\n[RDotNet](http://rdotnet.codeplex.com/) which is also covered by the BSD license.\nFor more information see the [License file][license] in the GitHub repository.\n\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork\nthe project and submit pull requests.\nMany thanks to Mathias Brandewinder for producing the [FAKE](https://github.com/fsharp/FAKE) script\nto build the NuGet package, and to Steffen Forkman for writing [FAKE](https://github.com/fsharp/FAKE).\n\n[gh]: https://github.com/fslaborg/RProvider\n[issues]: https://github.com/fslaborg/RProvider/issues\n[license]: https://github.com/fslaborg/RProvider/blob/master/LICENSE.md\n"},{"uri":"/RProvider/plugins.html","title":"Plugins\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\n# Plugins\n\nRProvider supports plugins to support custom functionality.  It uses [MEF](http://msdn.microsoft.com/en-us/library/dd460648.aspx) to load plugins that export certain contracts.  See below for examples.\n\nBefore implementing a plugin you should consider whether your conversion is universally applicable and should be added to the core conversion logic in the provider.  If so, please log as an issue, and ideally fork the repo and submit a pull request.\n\n## Supporting an implicit parameter conversion for a datatype \n\n## Supporting an explicit result conversion for a datatype\n\n## Supporting a default result conversion"},{"uri":"/RProvider/whatwhy.html","title":"Whats and Whys\n","content":"---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n\n# Whats and Whys\n\n## What is R?\n\n[R](http://www.r-project.org/) is an Open Source package for statistical computing.  There are a wide range of community-developed packages available that are very useful in the statistical computing/econometrics space.\n\nR is an interpreted, dynamically typed language that is typically used from its GUI or command line interactive environment.  But R is also embeddable using the R.DLL.\n\n## What is F#?\n\n[F#](http://msdn.microsoft.com/en-us/vstudio/hh388569) is a mixed-paradigm language that supports functional, object-oriented and imperative programming, with the emphasis on functional.  F# runs on the .NET runtime and is a compiled, statically typed language with a strong type system and type inference.  F# is typically used in the scientific/numerical computing space, though is quite widely applicable.\n\n## Why use R with F#?\n\nWhile there are a number of math/statistical packages available for the .NET platform, none of the approach the power of the packages that are available for R.  R also includes versatile packages for visualization which are hard to match on .NET.\n\n## What is a Type Provider?\n\nF# 3.0 supports a new feature called [Type Providers](http://msdn.microsoft.com/en-us/library/hh156509.aspx) which allow a set of types and members to be determined at compile time (or in the IDE) based on statically known parameters and (optionally) access to some external resource.  The primary purpose of Type Providers is to support strongly-typed access to external data sources, without the additional step of code generation, which adds friction to the development process and is sometimes impractical due to the size of the type space.  Type Providers can also be used to interoperate with another language or runtime environment, by introspecting on constructs available in that environment during compile time and making equivalent constructs available to F#.\n\n## Why not just use R directly?\n\nIn some cases, this will make a lot of sense, but there are a number of reasons why it might not:\n\n1. F# is particularly well-suited for the retrieval and manipulation/cleansing of data, which we will subsequently want to use in statistical models.\n2. We can combine functionality in .NET libraries (or otherwise callable from F#) with R functionality in a low-friction way.\n3. F# is well-suited to building scalable production applications, and using the R type provider allows us to use R functionality from those applications?\n"},{"uri":"/RProvider/mac-and-linux.html","title":"Using R provider on Mac and Linux\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n#r \u0022RProvider.dll\u0022\n#r \u0022RProvider.DesignTime.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \nUsing R provider on Mac and Linux\n=================================\n\nThe most recent versions of the R type provider can be used on Mac and Linux using\nMono. However, there is a bit of setup that you need to go through first. This page\ndescribes the necessary steps for using R provider on Mac using Xamarin Studio, but\nit should be easily adaptable for other configuration. If no, please [edit this \nfile](https://github.com/fslaborg/RProvider/blob/master/docs/content/mac-and-linux.fsx)\nto add more details!\n\nIn summary, you need the following:\n\n - Prerequisite: install R from [R-project.org](https://www.r-project.org/)\n - Install 64 bit version of Mono, because the default installation is\n   32 bit and R provider only works with 64 bit version.\n - Tell Xamarin Studio to run 64 bit version of the F# compiler and F# Interactive.\n - Create a file \u0060~/.rprovider.conf\u0060 with configuration that tells R provider\n   where to find 64 bit version of mono and where to find the R installation.\n\nInstalling 64 bit Mono\n----------------------\nMono currently offers a preview of a [Universal package](http://www.mono-project.com/download/#download-mac) \nfor installing of 64 bit version of Mono. Download the *Mono Universal Installer*\nand follow the installation instructions. After installation, you can run the 64 bit version of\nMono using the command\n\t\n\t[lang=bash]\n\tmono64\n\nIf you want to build 64 bit Mono manually, there are instructions at the bottom of this page.\n\nRunning F# in 64 bit\n--------------------------------\nThe standard launcher for F# compiler under Mono is \u0060fsharpc\u0060, and the launcher for F# Interactive\nis \u0060fsharpi\u0060. On a Mac they are installed under \u0060/usr/local/bin/\u0060, and they point to the Mono\ninstallation folder (something like \u0060/Library/Frameworks/Mono.framework/Versions/4.2.1/bin/\u0060).\n\nCreate copies of the two files by running the following commands: \n\n\t[lang=bash]\n\tsudo cp /usr/local/bin/fsharpi /usr/local/bin/fsharpi64\n\tsudo cp /usr/local/bin/fsharpc /usr/local/bin/fsharpc64\n\nWe\u0027ll use them to create the 64 bit launch scripts (if you don\u0027t have\nadmin privileges, copy the files to some other location). \nNow open the \u0060fsharpi64\u0060 file and edit the last line to use \u0060mono64\u0060 instead of \u0060mono\u0060. \nThe result should look like the following:\n\n\t[lang=bash]\n\t$EXEC /Library/Frameworks/Mono.framework/Versions/Current/bin/mono64 \\\n\t\t$DEBUG $MONO_OPTIONS \\\n\t\t/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.5/fsi.exe \\\n\t\t--exename:$(basename \u0022$0\u0022) \u0022$@\u0022\n \n*Optional*: you can also change the folder name pointing to a specific version of Mono\nto the \u0060Current\u0060 version. This should keep the launch script working even if you update Mono. \nThe code above uses the \u0060Current\u0060 version of Mono.\n\nNow you can test the installation by running \u0060fsharpi64\u0060 in the Terminal and typing in\n\n\t[lang=text]\n\tSystem.IntPtr.Size;;\n\nIf the result is 8, then all is working correctly and you are running the 64 bit version.\nIf the result is 4, then something went wrong and you are still using the 32 bit version\nof Mono.\n\nNow repeat the same steps with \u0060fsharpc64\u0060 launcher file to change \u0060mono\u0060 to \u0060mono64\u0060. \nThe last line in the launch script should look like the following:\n\n\t[lang=bash]\n\t$EXEC /Library/Frameworks/Mono.framework/Versions/Current/bin/mono64 \\ \n\t\t$DEBUG $MONO_OPTIONS \\\n\t\t/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.5/fsc.exe \\\n\t\t--exename:$(basename \u0022$0\u0022) \u0022$@\u0022\n\nIf you are using Xamarin Studio, you can now tell it to use \u0060fsharpi64\u0060 instead of \u0060fsharpi\u0060,\nand \u0060fsharpc64\u0060 instead of \u0060fsharpc\u0060. To do this, go to \u0060Preferences \u003E Other \u003E F# Settings\u0060. \n\n* Change the default F# interactive path to the path \u0060/usr/local/bin/fsharpi64\u0060.\n* Change the default F# compiler path to \u0060/usr/local/bin/fsharpc64\u0060. \n\nNow restart Xamarin Studio for the changes to take place. \nYou can again test which version of F# Interactive you\u0027re running \nby entering \u0060System.IntPtr.Size\u0060 \n(if the result is 4, you\u0027re running 32 bit; if the result is 8, you\u0027re on a 64 bit).\n\nConfiguring R provider\n----------------------\n\nFinally, you need to tell the R provider where to find the 64 bit installation of Mono (the\nR provider starts a background process to communicate with R using the 64 bit version). To \ndo that, we need to create a file \u0060~/.rprovider.conf\u0060 (that is, in your home folder) containing \nthe location of \u0060mono64\u0060 and location of your R installation in the \u0060MONO64\u0060 and \u0060R_HOME\u0060 variables.  \n\n    [lang=text]\n    echo -e \u0022MONO64=\u0060which mono64\u0060\\nR_HOME=\u0060R --print-home\u0060\u0022 \u003E ~/.rprovider.conf\n\nAnd this is all you should need! The command assumes that you have both \u0060mono64\u0060 and\n\u0060R\u0060 in your \u0060PATH\u0060. Check the \u0060~/.rprovider.conf\u0060 file\nif the locations of \u0060mono64\u0060 and R were generated correctly. The\n\u0060R_HOME\u0060 variable should point to the folder holding your R installation. \n\nIf calling \u0060R --print-home\u0060 did not work, you\u0027ll need to edit the environment variable\n\u0060R_HOME\u0060 and point it to the R home folder on your system. On Mac, this is something like \n\u0060/Library/Frameworks/R.framework/Resources\u0060 (check that \u0060$R_HOME/lib/libR.dylib\u0060 exists).\n\nTesting the R provider\n----------------------\n\nNow you can open Xamarin Studio and start playing with the R type provider. The easiest way\nto do that is to create a new F# Tutorial, add a new file (say \u0060Test.fsx\u0060) and reference\nR provider using NuGet (right click on the project \u0060Add \u003E Add Packages...\u0060 and search\nfor \u0022rprovider\u0022).\n\nNow, type the following in the script file (with the correct R provider version):\n*)\n#nowarn \u0022211\u0022\n#I \u0022packages/RProvider.1.1.19\u0022\n#load \u0022RProvider.fsx\u0022\n\nopen RProvider\nopen RProvider.graphics\nopen RProvider.grDevices\nopen RProvider.datasets\n(**\nThe \u0060#load\u0060 command loads the R provider. The first line disables warnings about unnecessary \nfolder references (a few are generated by the loader script). Finally, the \u0060open\u0060 declarations\nopen a number of standard R packages.\n\nNow we can run some calculations and create charts. When using R on Mac, the default graphics\ndevice (Quartz) sometimes hangs, but X11 is working without issues, so the following uses X11:\n*)\n// basic test if RProvider works correctly\nR.mean([1;2;3;4])\n// val it : RDotNet.SymbolicExpression = [1] 2.5\n\n// testing graphics\nR.x11()\n\n// Calculate sin using the R \u0027sin\u0027 function\n// (converting results to \u0027float\u0027) and plot it\n[ for x in 0.0 .. 0.1 .. 3.14 -\u003E \n    R.sin(x).GetValue\u003Cfloat\u003E() ]\n|\u003E R.plot\n\n// Plot the data from the standard \u0027Nile\u0027 data set\nR.plot(R.Nile)\n(**\nDiagnostics and debugging\n-------------------------\n\nIf you encounter any issues, please do not hesitate to submit an issue! You can do that on the\n[GitHub page](https://github.com/fslaborg/RProvider/issues). Before submitting\nan issue, please see the [Diagnostics and debugging page](diagnostics.html), which tells you how\nto create a log file with more detailed information about the issues.\n\nNote: Manual installation 64 bit version of Mono\n------------------------------------------\nThe Mono project currently offers a [preview version](http://www.mono-project.com/download/#download-mac) \nof an installer for 64 bit version of Mono. If you however need to install Mono manually, \nthe following section describes the necessary steps.\n\nThis page is based on [this write-up on running R.NET on \nMac](http://rawgit.com/evelinag/Projects/master/RDotNetOnMac/output/RDotNetOnMac.html) by \n[Evelina Gabasova](http://evelinag.com/). The page has some more details and hints that\nyou may need if the simplified version below does not work for you.\n\n### Installing 64 bit version of Mono\n\nFirst of all, you need 64 bit version of Mono. To do this, you\u0027ll need command line tools\n\u0060autoconf\u0060, \u0060automake\u0060 and \u0060libtool\u0060. Probably the easiest way to do this is to install\n[Homebrew](http://brew.sh/) (but feel free to use your favorite tool) and then run:\n\n    [lang=text]\n    brew install automake\n    brew install autoconf\n    brew install libtool\n\nNow you can use \u0060git\u0060 to get the latest version of Mono from GitHub and install it. The \nfollowing installs it into \u0060/usr/local/mono64\u0060 (feel free to change this too):\n\n    [lang=text]\n    export MONO_PREFIX=/usr/local/mono64\n    git clone https://github.com/mono/mono.git\n    cd mono\n    ./autogen.sh --prefix=$MONO_PREFIX --disable-nls  \n    make\n    make install\n\nYou might get a timeout from \u0060git\u0060 when running the \u0060autogen\u0060-command, if you are behind\na firewall. To fix this just run the following, which will force \u0060git\u0060 to clone using\n\u0022https://\u0022 instead of \u0022git://\u0022:\n\n    [lang=text]\n    git config --global url.\u0022https://\u0022.insteadOf git://\n\nNow we can run Mono in 64-bit explicitly using \u0060/usr/local/mono64/bin/mono\u0060. \n*)\n\n\n\n\n\n"},{"uri":"/RProvider/diagnostics.html","title":"Diagnostics and debugging\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\nDiagnostics and debugging\n=========================\n\nThe R type provider has an extensive logging to help developers diagnose\npotential issues. If you encounter any issues with the R type provider, this\npage gives you all the information you need to create a log file with detailed\ntrace of what is going one. This may give you some hints on what is wrong \u0026 a\ndetailed report that you can send when [submitting an\nissue](https://github.com/fslaborg/RProvider/issues).\n\n**TL;DR** The logging is enabled by setting an environment variable\n\u0060RPROVIDER_LOG\u0060 to a file name where the log should be saved. The file does\nnot have to exist, but the folder where it is located has to.\n\nEnabling logging on Windows\n---------------------------\n\nOn Windows, you can set environment variables by going to system properties\n(this varies depending on the OS version, but generally right click on\n\u0022My Computer\u0022 and select a link or button saying something like \u0022Change settings\u0022).\n\nThis should open a new dialog, where you can go to \u0022Advanced\u0022, and click on the\n\u0022Environment Variables\u0022 button. Here, you can add the variable as either per-user\nor per-system and save it. For example, create a folder \u0060C:\\Temp\u0060 and set\n\u0060RPROVIDER_LOG\u0060 to \u0060C:\\Temp\\rlog.txt\u0060. After you restart Visual Studio, the\nR provider will start logging.\n\nEnabling logging on Mac/Linux\n-----------------------------\n\nIf you\u0027re using Xamarin Studio on Mac, then the easiest option is to set the\nvariable from Terminal and then start Xamarin Studio from terminal. Note that\nif you set the environment variable from terminal, but launch Xamarin Studio\nfrom Dock or in some other way, it will not see the variable!\n\nThe following should do the trick (assuming the folder \u0060/Users/tomasp/Temp\u0060 exists):\n\n    [lang=text]\n    export RPROVIDER_LOG=/Users/tomasp/Temp/rlog.txt\n    open -n /Applications/Xamarin\\ Studio.app/\n\nThis will set the variable and start a new instance of Xamarin Studio in the current\ncontext. Once it appears, reporduce the operation that causes the error, close\nXamarin Studio and look at the log file.\n\nEnabling logging in a custom build\n----------------------------------\n\nIf you\u0027re building R provider from source, you can also enable logging by changing\nthe \u0060loggingEnabled\u0060 constant in the source code (and change \u0060logFile\u0060 if you want\nto override the default location). See the [right place for this on\nGitHub](https://github.com/fslaborg/RProvider/blob/master/src/RProvider/Logging.fs#L13).\n"}]